"""
Type stubs for logging.handlers
"""
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type, Union, IO, TextIO
import logging
import os
import sys
import time
from datetime import time as Time

class BaseRotatingHandler(logging.Handler):
    def __init__(self, filename: str, mode: str, encoding: Optional[str] = None, delay: bool = False, errors: Optional[str] = None) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...
    def rotation_filename(self, default_name: str) -> str: ...
    def rotate(self, source: str, dest: str) -> None: ...

class RotatingFileHandler(BaseRotatingHandler):
    def __init__(self, filename: str, mode: str = 'a', maxBytes: int = 0, backupCount: int = 0, encoding: Optional[str] = None, delay: bool = False, errors: Optional[str] = None) -> None: ...
    def doRollover(self) -> None: ...
    def shouldRollover(self, record: logging.LogRecord) -> bool: ...

class TimedRotatingFileHandler(BaseRotatingHandler):
    def __init__(self, filename: str, when: str = 'h', interval: int = 1, backupCount: int = 0, encoding: Optional[str] = None, delay: bool = False, utc: bool = False, atTime: Optional[Time] = None, errors: Optional[str] = None) -> None: ...
    def doRollover(self) -> None: ...
    def shouldRollover(self, record: logging.LogRecord) -> bool: ...
    def computeRollover(self, currentTime: float) -> int: ...
    def getFilesToDelete(self) -> List[str]: ...

class WatchedFileHandler(logging.Handler):
    def __init__(self, filename: str, mode: str = 'a', encoding: Optional[str] = None, delay: bool = False, errors: Optional[str] = None) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class SocketHandler(logging.Handler):
    def __init__(self, host: str, port: int) -> None: ...
    def makeSocket(self, timeout: float = 1.0) -> Any: ...
    def makePickle(self, record: logging.LogRecord) -> bytes: ...
    def send(self, s: bytes) -> None: ...
    def createSocket(self) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...
    def handleError(self, record: logging.LogRecord) -> None: ...
    def close(self) -> None: ...

class DatagramHandler(SocketHandler):
    def __init__(self, host: str, port: int) -> None: ...
    def makeSocket(self, timeout: float = 1.0) -> Any: ...
    def send(self, s: bytes) -> None: ...

class SysLogHandler(logging.Handler):
    def __init__(self, address: Union[Tuple[str, int], str] = ('localhost', 514), facility: int = 1, socktype: Optional[int] = None) -> None: ...
    def encodePriority(self, facility: Union[int, str], priority: Union[int, str]) -> int: ...
    def mapPriority(self, levelName: str) -> int: ...
    def emit(self, record: logging.LogRecord) -> None: ...
    def close(self) -> None: ...

class NTEventLogHandler(logging.Handler):
    def __init__(self, appname: str, dllname: Optional[str] = None, logtype: str = 'Application') -> None: ...
    def getEventCategory(self, record: logging.LogRecord) -> int: ...
    def getEventType(self, record: logging.LogRecord) -> int: ...
    def getMessageID(self, record: logging.LogRecord) -> int: ...
    def emit(self, record: logging.LogRecord) -> None: ...
    def close(self) -> None: ...

class SMTPHandler(logging.Handler):
    def __init__(self, mailhost: Union[str, Tuple[str, int]], fromaddr: str, toaddrs: List[str], subject: str, credentials: Optional[Tuple[str, str]] = None, secure: Optional[Union[Tuple[str, ...], bool]] = None, timeout: float = 5.0) -> None: ...
    def getSubject(self, record: logging.LogRecord) -> str: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class BufferingHandler(logging.Handler):
    def __init__(self, capacity: int) -> None: ...
    def shouldFlush(self, record: logging.LogRecord) -> bool: ...
    def emit(self, record: logging.LogRecord) -> None: ...
    def flush(self) -> None: ...
    def close(self) -> None: ...

class MemoryHandler(BufferingHandler):
    def __init__(self, capacity: int, flushLevel: int = 40, target: Optional[logging.Handler] = None, flushOnClose: bool = False) -> None: ...
    def shouldFlush(self, record: logging.LogRecord) -> bool: ...
    def setTarget(self, target: Optional[logging.Handler]) -> None: ...
    def flush(self) -> None: ...
    def close(self) -> None: ...

class HTTPHandler(logging.Handler):
    def __init__(self, host: str, url: str, method: str = 'GET', secure: bool = False, credentials: Optional[Tuple[str, str]] = None, context: Optional[Any] = None) -> None: ...
    def mapLogRecord(self, record: logging.LogRecord) -> Dict[str, Any]: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class QueueHandler(logging.Handler):
    def __init__(self, queue: Any) -> None: ...
    def prepare(self, record: logging.LogRecord) -> Any: ...
    def enqueue(self, record: Any) -> None: ...
    def emit(self, record: logging.LogRecord) -> None: ...

class QueueListener:
    def __init__(self, queue: Any, *handlers: logging.Handler, respect_handler_level: bool = False) -> None: ...
    def dequeue(self, block: bool) -> Any: ...
    def start(self) -> None: ...
    def prepare(self, record: Any) -> logging.LogRecord: ...
    def handle(self, record: logging.LogRecord) -> None: ...
    def enqueue_sentinel(self) -> None: ...
    def stop(self) -> None: ...
