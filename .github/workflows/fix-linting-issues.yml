name: Fix Linting Issues

on:
  workflow_dispatch:
    inputs:
      specific_file:
        description: 'Specific file to fix'
        required: false
        type: string
      check_only:
        description: 'Check only, do not fix'
        required: false
        default: false
        type: boolean
      no_ruff:
        description: 'Skip Ruff linter'
        required: false
        default: false
        type: boolean
      verbose:
        description: 'Enable verbose output'
        required: false
        default: true
        type: boolean
      exclude:
        description: 'Patterns to exclude (comma-separated)'
        required: false
        type: string
      exclude_file:
        description: 'Path to file containing exclude patterns'
        required: false
        type: string
      parallel:
        description: 'Enable parallel processing'
        required: false
        default: true
        type: boolean
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.py'
  push:
    branches:
      - main
    paths:
      - '**.py'

permissions:
  contents: write    # For push branch
  pull-requests: write    # For PR updates

jobs:
  fix-linting-issues:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0  # Fetch full history and all files

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Cache uv dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/uv
            ~/.uv
          key: ${{ runner.os }}-uv-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-uv-

      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Create virtual environment
        run: |
          uv venv .venv || {
            echo "Failed to create virtual environment with uv. Falling back to Python's venv module..."
            python -m venv .venv
          }
          source .venv/bin/activate

      - name: Install dependencies
        run: |
          source .venv/bin/activate

          # Install basic tools with uv pip
          uv pip install setuptools wheel ruff || {
            echo "Failed to install packages with uv pip. Installing uv in the virtual environment..."
            python -m pip install --upgrade uv
            uv pip install setuptools wheel ruff
          }

          # Install project dependencies
          if [ -f requirements-dev.txt ]; then
            uv pip install -r requirements-dev.txt
          fi
          if [ -f requirements.txt ]; then
            uv pip install -r requirements.txt
          fi

          # Install the package in development mode
          uv pip install -e .

      - name: Check if fix_linting_issues.py exists
        id: check-script
        run: |
          if [ -f "fix_linting_issues.py" ]; then
            echo "script_exists=true" >> $GITHUB_OUTPUT
            echo "Script found, proceeding..."
          else
            echo "script_exists=false" >> $GITHUB_OUTPUT
            echo "Warning: fix_linting_issues.py not found!"
          fi

      - name: Fix linting issues
        if: steps.check-script.outputs.script_exists == 'true'
        run: |
          # Build command with appropriate flags
          CMD="python fix_linting_issues.py"

          if [[ "${{ inputs.check_only }}" == "true" ]]; then
            CMD+=" --check"
          fi

          if [[ "${{ inputs.no_ruff }}" == "true" ]]; then
            CMD+=" --no-ruff"
          fi

          # Always use verbose mode in CI for better logs
          CMD+=" --verbose"

          # Add exclude patterns if provided
          if [[ -n "${{ inputs.exclude }}" ]]; then
            # Split comma-separated patterns and add each as a separate --exclude argument
            IFS=',' read -ra EXCLUDE_PATTERNS <<< "${{ inputs.exclude }}"
            for pattern in "${EXCLUDE_PATTERNS[@]}"; do
              CMD+=" --exclude \"${pattern}\""
            done
          fi

          # Add exclude file if provided
          if [[ -n "${{ inputs.exclude_file }}" ]]; then
            CMD+=" --exclude-file \"${{ inputs.exclude_file }}\""
          fi

          # Add parallel processing if enabled
          if [[ "${{ inputs.parallel }}" == "true" ]]; then
            # Use half the available CPU cores for parallel processing
            CPU_COUNT=$(nproc)
            WORKER_COUNT=$((CPU_COUNT / 2))
            if [[ $WORKER_COUNT -lt 1 ]]; then
              WORKER_COUNT=1
            fi
            CMD+=" --jobs $WORKER_COUNT"
          fi

          # Run the command with specific file or all files
          if [[ -n "${{ inputs.specific_file }}" ]]; then
            FILE_PATH="${{ inputs.specific_file }}"
            if [[ -f "$FILE_PATH" ]]; then
              echo "Fixing specific file: $FILE_PATH"
              $CMD "$FILE_PATH"
            else
              echo "Error: File $FILE_PATH not found!"
              exit 1
            fi
          else
            echo "Fixing all Python files..."
            # Run with retry mechanism for better reliability
            MAX_RETRIES=2
            RETRY_COUNT=0
            SUCCESS=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" != "true" ]; do
              if [ $RETRY_COUNT -gt 0 ]; then
                echo "Retry attempt $RETRY_COUNT of $MAX_RETRIES..."
              fi

              if $CMD; then
                SUCCESS=true
              else
                RETRY_COUNT=$((RETRY_COUNT+1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Command failed, will retry in 5 seconds..."
                  sleep 5
                else
                  echo "Command failed after $MAX_RETRIES attempts."
                  # Continue workflow even if fixing fails
                  # The commit step will only run if there are changes
                fi
              fi
            done
          fi

      - name: Fallback to standard tools
        if: steps.check-script.outputs.script_exists != 'true'
        run: |
          echo "Using standard tools as fallback..."

          # Run Ruff for linting and formatting
          if [[ "${{ inputs.no_ruff }}" != "true" ]]; then
            echo "Running Ruff linter..."

            # Process Python files in batches for better reliability
            echo "Finding Python files..."
            PYTHON_FILES=$(find . -name "*.py" -not -path "*/\.*" -not -path "*/venv/*" -not -path "*/.venv/*" -not -path "*/node_modules/*")
            TOTAL_FILES=$(echo "$PYTHON_FILES" | wc -l)
            echo "Found $TOTAL_FILES Python files"

            # Process files in batches
            BATCH_SIZE=50
            CURRENT=0
            SUCCESS_COUNT=0
            FAILED_FILES=()

            for FILE in $PYTHON_FILES; do
              CURRENT=$((CURRENT+1))

              if [[ $((CURRENT % BATCH_SIZE)) -eq 1 ]]; then
                BATCH_END=$((CURRENT+BATCH_SIZE-1))
                if [[ $BATCH_END -gt $TOTAL_FILES ]]; then
                  BATCH_END=$TOTAL_FILES
                fi
                echo "Processing files $CURRENT-$BATCH_END of $TOTAL_FILES..."
              fi

              if [[ "${{ inputs.check_only }}" == "true" ]]; then
                if ruff check "$FILE"; then
                  SUCCESS_COUNT=$((SUCCESS_COUNT+1))
                else
                  FAILED_FILES+=("$FILE")
                fi
              else
                if ruff check --fix "$FILE" && ruff format "$FILE"; then
                  SUCCESS_COUNT=$((SUCCESS_COUNT+1))
                else
                  FAILED_FILES+=("$FILE")
                fi
              fi

              # Show progress after each batch
              if [[ $((CURRENT % BATCH_SIZE)) -eq 0 ]] || [[ $CURRENT -eq $TOTAL_FILES ]]; then
                echo "Progress: $CURRENT/$TOTAL_FILES files processed ($SUCCESS_COUNT successful, ${#FAILED_FILES[@]} failed)"
              fi
            done

            echo "Completed processing $TOTAL_FILES files ($SUCCESS_COUNT successful, ${#FAILED_FILES[@]} failed)"
            if [[ ${#FAILED_FILES[@]} -gt 0 ]]; then
              echo "Failed files:"
              for FILE in "${FAILED_FILES[@]}"; do
                echo "  - $FILE"
              done
              # Continue workflow even if some files failed
            fi
          fi

      - name: Check for changes
        id: git-check
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected:"
            git status --porcelain
          else
            echo "No changes detected"
          fi

      - name: Commit changes
        if: steps.git-check.outputs.changes == 'true' && inputs.check_only != 'true'
        run: |
          # Configure git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Get list of changed files for commit message
          CHANGED_FILES=$(git diff --name-only)
          CHANGED_COUNT=$(echo "$CHANGED_FILES" | wc -l)

          # Create a more informative commit message
          COMMIT_MSG="Auto-fix linting issues in $CHANGED_COUNT files"

          # Add a summary of changes to the commit message
          if [[ $CHANGED_COUNT -le 10 ]]; then
            # List all files if 10 or fewer
            COMMIT_MSG="$COMMIT_MSG\n\nFiles fixed:"
            while IFS= read -r file; do
              COMMIT_MSG="$COMMIT_MSG\n- $file"
            done <<< "$CHANGED_FILES"
          else
            # Just summarize by directory if more than 10 files
            DIRS=$(dirname $(echo "$CHANGED_FILES") | sort | uniq -c | sort -nr)
            COMMIT_MSG="$COMMIT_MSG\n\nDirectories with fixes:"
            while IFS= read -r dir_info; do
              COMMIT_MSG="$COMMIT_MSG\n- $dir_info"
            done <<< "$DIRS"
          fi

          # Commit and push changes
          git add .
          git commit -m "$(echo -e "$COMMIT_MSG")"
          git push
