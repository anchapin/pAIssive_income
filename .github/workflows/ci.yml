name: CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      lint_only:
        description: 'Run only linting checks'
        required: false
        default: false
        type: boolean
      test_only:
        description: 'Run only tests'
        required: false
        default: false
        type: boolean
      specific_file:
        description: 'Specific file to lint or test'
        required: false
        type: string
      test_path:
        description: 'Path to test directory or file'
        required: false
        default: 'tests/'
        type: string
      skip_docker:
        description: 'Skip Docker build'
        required: false
        default: false
        type: boolean

jobs:
  lint:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ruff flake8 black isort mypy
      - name: Run Ruff
        run: |
          ruff check .
          ruff format --check .
      - name: Run flake8
        run: flake8 .
      - name: Run black (check only)
        run: black --check .
      - name: Run isort (check only)
        run: isort --check-only .
      - name: Run mypy
        run: mypy .

  lint_and_test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: ${{ !github.event.inputs.test_only }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: Install dependencies
      run: |
        # Clean up any existing .egg-info directories to prevent conflicts
        find . -type d -name "*.egg-info" -exec rm -rf {} + || true
        python -m pip install --upgrade pip
        python -m pip install ruff mypy pyright
        python -m pip install -r requirements-dev.txt
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

    - name: Cache Python packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
          .mypy_cache
          .ruff_cache
          .pytest_cache
        key: ${{ runner.os }}-pip-lint-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-lint-

    - name: Create syntax check script
      run: |
        echo "Creating syntax check script..."
        echo '#!/bin/bash
        # Simple script to check Python syntax

        # Check a specific file
        check_file() {
          python -m py_compile "$1" 2>/dev/null
          if [ $? -ne 0 ]; then
            echo "Syntax error in $1"
            return 1
          fi
          return 0
        }

        # Find all Python files excluding common directories to ignore
        find_python_files() {
          find . -name "*.py" -type f -not -path "*/\.*" -not -path "*/venv/*" -not -path "*/.venv/*" -not -path "*/build/*" -not -path "*/dist/*" -not -path "*/__pycache__/*"
        }

        # Main function
        main() {
          if [ $# -gt 0 ]; then
            # Check specific files provided as arguments
            for file in "$@"; do
              check_file "$file" || exit 1
            done
          else
            # Find and check all Python files
            files=$(find_python_files)
            if [ -z "$files" ]; then
              echo "No Python files found"
              exit 0
            fi

            for file in $files; do
              check_file "$file" || exit 1
            done
          fi

          echo "All Python files passed syntax check"
          exit 0
        }

        # Run the main function with all arguments
        main "$@"' > syntax_check.sh
                chmod +x syntax_check.sh

    - name: Create file path validation script
      run: |
        echo "Creating file path validation script..."
        echo '#!/bin/bash
        # Script to validate file paths to prevent command injection
        # Usage: validate_file_path.sh <file_path> [<default_path>]
        # Returns the validated path or the default path if validation fails

        # Function to validate a file path
        validate_file_path() {
          local file_path="$1"
          local default_path="${2:-}"

          # Remove newlines and other control characters
          local clean_path=$(echo "$file_path" | tr -d '"'"'\n'"'"' | sed '"'"'s/[^a-zA-Z0-9_\.\/-]//g'"'"')

          # Validate path - only allow alphanumeric characters, underscores, dots, dashes, and slashes
          if [[ "$clean_path" =~ ^[a-zA-Z0-9_\.\/-]+$ ]]; then
            # Path is valid, check if it exists (if not empty)
            if [ -n "$clean_path" ] && [ ! -e "$clean_path" ]; then
              echo "Warning: Path '"'"'$clean_path'"'"' does not exist." >&2
              # Still return the path if it'"'"'s syntactically valid
              echo "$clean_path"
            else
              # Path exists or is empty, return it
              echo "$clean_path"
            fi
          else
            # Invalid path, use default
            echo "Warning: Invalid path provided. Using default path instead." >&2
            echo "$default_path"
          fi
        }

        # Main script execution
        if [ $# -lt 1 ]; then
          echo "Usage: $0 <file_path> [<default_path>]" >&2
          exit 1
        fi

        validate_file_path "$1" "${2:-}"' > validate_file_path.sh
        chmod +x validate_file_path.sh

    - name: Check for syntax errors
      run: |
        # Run the syntax check script
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            # Check if the file is a Python file before syntax checking
            if [[ "$FILE_PATH" == *.py ]]; then
              echo "Checking syntax for specific Python file: $FILE_PATH"
              ./syntax_check.sh "$FILE_PATH"
            else
              echo "Skipping syntax check for non-Python file: $FILE_PATH"
            fi
          else
            echo "Invalid file path provided. Checking all Python files instead."
            ./syntax_check.sh
          fi
        else
          echo "Checking syntax for all Python files..."
          ./syntax_check.sh
        fi

    - name: Lint with Ruff
      run: |
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            # Check if the file is a Python file before linting
            if [[ "$FILE_PATH" == *.py ]]; then
              echo "Linting specific Python file with Ruff: $FILE_PATH"
              ruff check "$FILE_PATH"
              ruff format --check "$FILE_PATH"
            else
              echo "Skipping Ruff linting for non-Python file: $FILE_PATH"
            fi
          else
            echo "Invalid file path provided. Linting all Python files instead."
            ruff check .
            ruff format --check .
          fi
        else
          echo "Linting all Python files with Ruff"
          ruff check .
          ruff format --check .
        fi

    # Remove auto-fixing in CI; only check and fail on error.
    - name: Fix formatting issues (if any)
      if: always()
      run: |
        echo "Checking that all files are formatted correctly (no auto-fix in CI)..."
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            # Check if the file is a Python file before fixing
            if [[ "$FILE_PATH" == *.py ]]; then
              echo "Checking specific Python file with Ruff: $FILE_PATH"
              ruff check "$FILE_PATH"
              ruff format --check "$FILE_PATH"
            else
              echo "Skipping Ruff formatting for non-Python file: $FILE_PATH"
            fi
          else
            echo "Invalid file path provided. Checking all Python files instead."
            ruff check .
            ruff format --check .
          fi
        else
          echo "Checking all Python files with Ruff"
          ruff check .
          ruff format --check .
        fi

    - name: Type check with mypy and pyright
      run: |
        set -e
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            # Check if the file is a Python file before type checking
            if [[ "$FILE_PATH" == *.py ]]; then
              echo "Type checking specific Python file: $FILE_PATH"
              mypy "$FILE_PATH" --ignore-missing-imports --install-types --non-interactive --explicit-package-bases
              pyright "$FILE_PATH"
            else
              echo "Skipping type checking for non-Python file: $FILE_PATH"
            fi
          else
            echo "Invalid file path provided. Type checking all Python files instead."
            mypy . --ignore-missing-imports --install-types --non-interactive --explicit-package-bases
            pyright .
          fi
        else
          echo "Type checking all Python files"
          mypy . --ignore-missing-imports --install-types --non-interactive --explicit-package-bases
          pyright .
        fi

    - name: Check for unused imports
      run: |
        set -e
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            # Check if the file is a Python file before checking imports
            if [[ "$FILE_PATH" == *.py ]]; then
              echo "Checking unused imports in specific Python file: $FILE_PATH"
              ruff check "$FILE_PATH" --select F401
            else
              echo "Skipping unused imports check for non-Python file: $FILE_PATH"
            fi
          else
            echo "Invalid file path provided. Checking all Python files instead."
            ruff check . --select F401
          fi
        else
          echo "Checking unused imports in all Python files"
          ruff check . --select F401
        fi

  test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !github.event.inputs.lint_only }}
    needs: lint
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.12']  # Focusing on Python 3.12 first

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        cache: pip

    - name: Cache Python packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
          .pytest_cache
        key: ${{ runner.os }}-pip-test-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-test-

    - name: Cleanup conflicting files
      run: |
        find . -type d -name "*.egg-info" -exec rm -rf {} + || true
        find . -type d -name "*.dist-info" -exec rm -rf {} + || true
        find . -name "*.egg" -exec rm -f {} + || true
        pip cache purge || true

        # Clear pip cache to avoid potential conflicts
        pip cache purge || true

    - name: Verify directories before installation
      run: |
        echo "Verifying directories:"
        find . -type d -name "*.egg-info"
        find . -type d -name "*.dist-info"

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        python -m pip install pytest pytest-cov pytest-xdist pytest-asyncio
        if [ -f requirements-dev.txt ]; then
          python -m pip install -r requirements-dev.txt
        fi
        if [ -f requirements.txt ]; then
          python -m pip install -r requirements.txt
        fi
        python -m pip install -e . -v

    - name: Create junit directory
      run: mkdir -p junit

    - name: Run tests (phased runner)
      env:
        PYTHONPATH: ${{ github.workspace }}
      run: |
        if [ -n "${{ github.event.inputs.specific_file }}" ]; then
          # Validate file path using the validation script
          FILE_PATH=$(./validate_file_path.sh "${{ github.event.inputs.specific_file }}")
          if [ -n "$FILE_PATH" ]; then
            echo "Testing specific file: $FILE_PATH"
            pytest "$FILE_PATH" \
              -v \
              --import-mode=importlib \
              --cov=. \
              --cov-report=xml \
              --cov-report=term-missing \
              --cov-fail-under=90 \
              --junitxml=junit/test-results.xml
          else
            echo "Invalid file path provided. Running all tests instead."
            pytest tests \
              -n auto \
              -v \
              --import-mode=importlib \
              --cov=. \
              --cov-report=xml \
              --cov-report=term-missing \
              --cov-fail-under=90 \
              --junitxml=junit/test-results.xml
          fi
        elif [ -n "${{ github.event.inputs.test_path }}" ]; then
          # Validate test path using the validation script
          TEST_PATH=$(./validate_file_path.sh "${{ github.event.inputs.test_path }}" "tests/")
          if [ -n "$TEST_PATH" ]; then
            echo "Testing path: $TEST_PATH"
            pytest "$TEST_PATH" \
              -n auto \
              --import-mode=importlib \
              --cov=. \
              --cov-report=xml \
              --cov-report=term-missing \
              --cov-fail-under=90 \
              --junitxml=junit/test-results.xml
          else
            echo "Invalid test path provided. Running all tests instead."
            pytest tests \
              -n auto \
              -v \
              --import-mode=importlib \
              --cov=. \
              --cov-report=xml \
              --cov-report=term-missing \
              --cov-fail-under=90 \
              --junitxml=junit/test-results.xml
          fi
        else
          echo "Running fast tests (default phase)"
          pytest -n auto -v \
            -m "not slow and not integration and not dependency and not performance" \
            --import-mode=importlib \
            --cov=. \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=90 \
            --junitxml=junit/test-results.xml
        fi

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: junit/test-results.xml

    - name: Upload coverage report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.xml

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage.xml

  build:
    runs-on: ubuntu-latest
    needs: test
    # Build Docker image if:
    # 1. This is a push to main or dev branch, OR
    # 2. This is a manual workflow run and skip_docker is not set to true
    if: (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')) || (github.event_name == 'workflow_dispatch' && !inputs.skip_docker)
    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Build Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: false
        tags: paissiveincome/app:test
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

    # Temp fix for https://github.com/docker/build-push-action/issues/252
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
